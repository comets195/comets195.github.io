<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-05T11:34:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Napster’iOS</title><subtitle>하루하루 열심히.</subtitle><author><name>Napster</name></author><entry><title type="html">[iOS] Layer란?</title><link href="http://localhost:4000/ui/CALayer/" rel="alternate" type="text/html" title="[iOS] Layer란?" /><published>2020-10-05T00:00:00+09:00</published><updated>2020-10-05T00:00:00+09:00</updated><id>http://localhost:4000/ui/CALayer</id><content type="html" xml:base="http://localhost:4000/ui/CALayer/">&lt;h1 id=&quot;calayer의-개념을-알아보자&quot;&gt;CALayer의 개념을 알아보자!&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;layer&quot;&gt;Layer&lt;/h1&gt;

&lt;p&gt;iOS에서의 모든 뷰는 Layer를 가지고있다. Layer는  UIView에 대한 bitmap정보를 포함하고있다. 이 정보들을 GPU에게 제공하여 그래픽처리의 이점을 가져온다. (OpenGL을 이용한 부드러운 화면처리) OpenGL을 직접적으로 다루기엔 너무 비효율적이다. 작은 일에도 많은양의 코드가 필요한 것도 하나의 이유이다. 이러한 불편점을 도움을 주기위해 Core Graphics는 만들어 졌고, 이걸 좀더 쉽게 사용하기위해 Core Animation이 만들어졌다. 이친구는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer &lt;/code&gt; 클래스를 제공해주고 기초단계의 낮은 수준의 그래픽 처리에 접근할 수 있게 해준다. 쉽게말해서 복잡한 OpenGL코드를 몇개의 개념을 모아서 좀더 쉽게 해주는 친구가 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;라는 뜻이다. (이렇게 쉽게 해준것도 잘 못쓰고있으니 참..)&lt;/p&gt;

&lt;p&gt;애플은또 Core Animation의 많은 기능들을 대부분의 앱에서 꼭 필요하지 안게 하기위해 UIKit이란걸 또 만들어주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.appcoda.com/wp-content/uploads/2016/08/calayer-intro-1024x655.png&quot; alt=&quot;애플에서 그려준 iOS drawing hierarchy&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 다양한 층을둔 것에 이점은, 프로그래머 마음대로 좀더 낮은 수준(성능을 주로 원하는 작업들, 유연한 커스텀뷰 작업)에 접근하는 코드를 작성할 수도 있고, 아닐 수도 있게 선택지를 준다는 점이다. UIView의 Layer에 여러가지 옵션들을 주고 그릴 수 있는게 주르르륵 있다.&lt;/p&gt;

&lt;h2 id=&quot;calayer-performance&quot;&gt;CALayer Performance&lt;/h2&gt;

&lt;p&gt;그럼 Layer를 이용한 성능향상 팁을 두가지 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drawsAsynchronously&lt;/code&gt; 이걸 true로 하면 CPU가 개입하여 백그라운드 스레드에서 그리는작업을 하게된다. 이건 redrawn이 빈번할때 예를들면 지도, 테이블뷰 라는데, 애플 공식문서에서는 해당 속성을 변경할때는 바꿔서 사용했을때 이점이 있는지 잘생각하고 사용하라고 한다. 기본값은 false이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldRasterize&lt;/code&gt; Rasterized(픽셀로 바꾸어 화면상으로 보여줌) 이게 true이면 Layer는 한번만 그려진다. 그리고 언제든 animated될때 다시그려지지 않고, 처음 설정할때 그려진 bitmap정보도 바뀌지 않는다. 그말은 애니메이션이되는 layer가아니라 가만히 있는 layer에 설정해주면 성능향상에 좋다는 것.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/10317653-calayer-tutorial-for-ios-getting-started&quot;&gt;Raywender 참고&lt;/a&gt;
&lt;a href=&quot;https://www.appcoda.com/calayer-introduction/&quot;&gt;appcoda blog 참고&lt;/a&gt;&lt;/p&gt;</content><author><name>Napster</name></author><summary type="html">CALayer의 개념을 알아보자!</summary></entry><entry><title type="html">JK가 보내주신 개발자의 단계</title><link href="http://localhost:4000/%EB%82%B4%EC%83%9D%EA%B0%81/myopinion/" rel="alternate" type="text/html" title="JK가 보내주신 개발자의 단계" /><published>2020-04-21T00:00:00+09:00</published><updated>2020-04-21T00:00:00+09:00</updated><id>http://localhost:4000/%EB%82%B4%EC%83%9D%EA%B0%81/myopinion</id><content type="html" xml:base="http://localhost:4000/%EB%82%B4%EC%83%9D%EA%B0%81/myopinion/">&lt;h1 id=&quot;나의-위치를-가늠해-볼-수-있는-약간의-시야&quot;&gt;나의 위치를 가늠해 볼 수 있는 약간의 시야&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;소프트웨어 개발 업계에 20년정도 있으면서 면접도 수백번 보고 여러 종류의 회사(단순 SW 하청 계약직부터 글로벌 SW기업까지)를 거치다보니 소프트웨어 엔지니어를 보는 개인적인 최소한의 룰(?)이 생긴것이 있는데, 이를 공유해볼까 합니다. 승진에 대한 피드백을 주다보니 자연스럽게 정리가 되더라고요. 매니지먼트 트랙이 아닌 개인 공헌자(IC)의 레벨에 대한 이야기이고 물론 개인적인 견해입니다.&lt;br /&gt;
먼저 연차는 크게 의미 없을 수가 있습니다. 그렇지만, (1년차 경험을 10년동안 하는 것이 아니라) 매년 비슷한 일만 반복하지 않고 도전적으로 성장을 해왔다고 가정하면 대략적인 연차는 의미가 있습니다.  경험은 압축해서 전달할 수 있는 것이 절대 아니라는 것을 알 수 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Associate Level: 갓 학교 졸업한 수준의 레벨인데, 이 분들은 명확하게 주어진 문제를 잘 풀풀면 됩니다. (기초 문제 해결 역량) 이것을 보는 가장 비용 효율적인 방법은 그냥 코딩 테스트를 보는 것입니다. 일반적으로 코딩 테스트는 입력과 출력이 명확하게 정해져있기 때문에 이것을 해결할 수 있는지(문제 해결), 인터뷰를 통해 어떻게 커뮤니케이션(협력)하고 접근하는지(태도)를 볼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mid Level: 대략 3~7년차 경험을 가진 SW엔지니어. 이 레벨은 약간의 모호한(?) 문제를 풀 수 있는 사람입니다. SW개발 프로젝트를 해보면 역시나 문제가 명확하게 정의되어 있지 않는 경우가 많습니다. 대략적으로 풀어야 할 문제는 정해져있는데, 세부적인 기획이나 설계가 없는 경우입니다. (약간의 회색 지대도 있고요.) 이런 경우 이해 당사자들과 협업을 하면서 풀어야할 문제를 구체화하고(설계) 그 문제를 풀수 있는 능력(문제 해결)이 필요합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Senior Level: 대략 7년차 이상 경험을 가진 SW엔지니어를 말하는데, 사실 이쪽은 레인지가 상당히 넓습니다. (경력 20년 이상인 분들도 많음) 그래서, 좀 큰 회사들은 Senior I, Senior II 또는 Lead, Staff등의 세분화된 등급으로 나누기도 합니다. 그래서, “딱 이런사람이 시니어다.”라는 것은 회사마다 업계마다 너무 달라서 정의하기 힘들지만, 최소한의 공통점은 찾을 수 있었습니다. 바로 이분들은 모호한 문제 해결을 넘어서, 주어진 프로젝트 상황에서 무엇을 풀어야 하는지 문제를 정의(!)할 수 있는 사람입니다. 프로젝트 단계(프로토타입-프리프로덕션-프로덕션-런칭)별로 어떤 문제를 우선적으로 풀어야 할지 정의할 수 있습니다. 그렇기 때문에 시니어 레벨이 있으면 프로젝트를 마칠수 있는 최소한(!)의 엔지니어링 역량을 가졌다고 보면 될 것 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Principal Level:  이분들은 일반적으로 SW엔지니어링 자체에만 매몰되지 않고 비즈니스 플로우에 대한 관심도 갖고 있기에 하나의 프로젝트를 넘어서 회사내의 여러 프로젝트에서 공통적으로 개선할 수 있는 부분들에 대한 Architecting이 가능한 것을 볼 수 있었습니다. 그래서 단순히 문제 정의를 넘어서, 여러 명이 먹고살(?) 길을 만드는 분들입니다. 그리고 이론적 기반같은 그 도메인의 Fundamental에 대해 상당히 깊은 이해를 갖고 있기 때문에 해당 도메인에 대한 끝판왕 같은 포스를 보여줍니다. 즉, 인더스트리 롤 모델 같은 분들입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Distinguished (Fellow) Level: 전세계적으로 SW 업계에서 누구나 다 아는 유명 엔지니어들..&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;체계(?), 대규모조직(많은 개발인력)일 수록 단계가 많이 나눠질 것 같다. 아직 경험해 보지 못해서 정확히 알 수는 없다.
 내가 몸담고 있는 회사에서는 적어도 2,3단계는 섞여 있는 것 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;주어진-프로젝트-상황에서-무엇을-풀어야-하는지-문제를-정의-할-수-있는-사람이-시니어&quot;&gt;“주어진 프로젝트 상황에서 무엇을 풀어야 하는지 문제를 정의! 할 수 있는 사람이 시니어.”&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다면 나는 어디에 속할 수 있고 어느 범주에 들어 갈 수 있는가? (2년차 개발자로써)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;3,4에 속할 수 있도록 힘써야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어느 글에서 연차는 중요 하지 않다고 쓰여진 것을 보았다. 그렇게 되려면 현재의 모습에 안주해서는 안된다.&lt;/p&gt;</content><author><name>Napster</name></author><summary type="html">나의 위치를 가늠해 볼 수 있는 약간의 시야</summary></entry><entry><title type="html">[Raywenderlich] Concurrency 1: 소개</title><link href="http://localhost:4000/concurrency/Concurrency1/" rel="alternate" type="text/html" title="[Raywenderlich] Concurrency 1: 소개" /><published>2020-04-20T00:00:00+09:00</published><updated>2020-04-20T00:00:00+09:00</updated><id>http://localhost:4000/concurrency/Concurrency1</id><content type="html" xml:base="http://localhost:4000/concurrency/Concurrency1/">&lt;h1 id=&quot;concurrency란-무엇인가&quot;&gt;Concurrency란 무엇인가?&lt;/h1&gt;
&lt;p&gt;회사의 프로젝트를 진행하면서 iOS의 동시성 프로그래밍의 개념 공부가 필요해졌었다. 
필요로 했던 기능은 이미지 업로드 서버 요청과 동시에 UI에 업로드 중이라는 변화를 보여줘야하는 기능이었다.&lt;/p&gt;

&lt;p&gt;가장 기본적인 내용인 UI는 꼭 Main Thread에서 실행해야한다 정도만 알고 있었고, 어떻게 다른 Thread에게 일을 시키면 되는지 알고 싶어 공부하게 되었다.&lt;/p&gt;

&lt;p&gt;책에서는 Concurrency, 동시성을 간단하게 말하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“같은 실행시간 동안 앱의 로직이나 랜덤하게 코드가 실행할때, 여전히 정확한 데이터 플로우대로 결과를 보여줘야 한다는 것.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;덮붙혀 모던 기기들은 한개 이상의 CPU를 가지고 있기 때문에, Single task 이상의 작업을 같은 시간안에 해결 할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;Q. 여담으로 A13칩은 몇코어?(6코어…)
&lt;img src=&quot;/assets/images/post-concurrency/1_apple_a13_bionic.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;왜-concurrency를-사용-해야-하는가&quot;&gt;왜 Concurrency를 사용 해야 하는가?&lt;/h1&gt;
&lt;p&gt;중요한 이야기다. 앱의 사용성을 높이기 위해서 사용해야한다. 너무 당연한 이야기 아닌가? 만약 MainThreed에서 동시에 여러일을 하게되면 분명히 UI는 프리징 되어 보여질 것!!
동시성을 사용하면서 생길 수 있는 좋은 부작용은 기능을 추가할때 전반적인 설계를 하는데 조금 더 많은 시간이 걸린 다는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;그럼-어떻게-사용하는데&quot;&gt;그럼 어떻게 사용하는데?&lt;/h1&gt;
&lt;p&gt;이게 이 시리즈의 초점이라고한다.(당연한 소’릴…)&lt;/p&gt;

&lt;p&gt;이 책을 끝맞치면 이런 스킬들이 생긴단다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;높은 수준의 구조를 가진 앱이 같은 시간안에 여러 태스크들을 동시에 실핼 할 수 있게 도와준다.&lt;/li&gt;
  &lt;li&gt;각자 다른 리소스에 태스크들이 접근을 할때, 공유 리소스는 읽기 전용으로만, 접근이 가능한 다른 쓰레드에서는 좀더 빠른 프로세싱을 할 수 있게 접근을 허용 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;

&lt;p&gt;당연한 소리를 하고있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;틀린점이나 이상한점이 있다면 제보 감사합니다. :)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Napster</name></author><summary type="html">Concurrency란 무엇인가? 회사의 프로젝트를 진행하면서 iOS의 동시성 프로그래밍의 개념 공부가 필요해졌었다. 필요로 했던 기능은 이미지 업로드 서버 요청과 동시에 UI에 업로드 중이라는 변화를 보여줘야하는 기능이었다.</summary></entry><entry><title type="html">Hello Swift World!</title><link href="http://localhost:4000/%EC%8B%9C%EC%9E%91/Hello-Swift/" rel="alternate" type="text/html" title="Hello Swift World!" /><published>2020-04-20T00:00:00+09:00</published><updated>2020-04-20T00:00:00+09:00</updated><id>http://localhost:4000/%EC%8B%9C%EC%9E%91/Hello%20Swift</id><content type="html" xml:base="http://localhost:4000/%EC%8B%9C%EC%9E%91/Hello-Swift/">&lt;h1 id=&quot;hello-swift-world&quot;&gt;Hello Swift World!&lt;/h1&gt;

&lt;p&gt;안녕하세요?
첫번째 포스팅입니다. 앞으로 블로그를 어떻게 운영하면 좋을지에 대한 간략한 소개들 정도 되겠네요.&lt;/p&gt;

&lt;p&gt;저는 iOS개발자 입니다. 아직 한참 배울께 많죠. 그래서 아는 것도 다시한번 정리해보는 시간을 갖는 것과 잘못 알고 있는 것을 피드백을 통해 고치려고합니다. 알게된 것들은 구글 검색을 통해 알게되는 것도 있겠지만 공식문서를 기반으로 알아가보려합니다.&lt;/p&gt;

&lt;p&gt;매주 혹은 2주마다 하나씩 큰 주제를 정하고 그에 맞는 공식문서의 내용과 내가 생각한게 맞는지를 검증하는 코드와 함께 포스팅을 할 예정입니다.&lt;/p&gt;

&lt;p&gt;꾸준히 블로그를 할 수 있길 바라며 이글을 시작으로 블로그를 시작해보려합니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;p&gt;Napster.&lt;/p&gt;</content><author><name>Napster</name></author><summary type="html">Hello Swift World!</summary></entry></feed>